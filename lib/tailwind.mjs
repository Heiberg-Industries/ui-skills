import { parseStyle, StyleNotFoundError } from './parser.mjs';

export async function handleGetTailwindConfig({ style, mode }) {
  try {
    const parsed = await parseStyle(style);

    if (parsed.isFreeform) {
      return {
        content: [{
          type: 'text',
          text: '// Freeform has no predefined tokens.\n// Define your own theme based on the project context.',
        }],
      };
    }

    const theme = { extend: {} };

    // Colors
    if (Object.keys(parsed.colors).length > 0) {
      theme.extend.colors = {};
      for (const [role, value] of Object.entries(parsed.colors)) {
        if (role.startsWith('_')) continue;
        theme.extend.colors[role] = value;
      }
    }

    // Font families
    if (Object.keys(parsed.fonts).length > 0) {
      theme.extend.fontFamily = {};
      for (const [role, stack] of Object.entries(parsed.fonts)) {
        theme.extend.fontFamily[role] = stack;
      }
    }

    // Border radius
    if (parsed.radii.length > 0) {
      theme.extend.borderRadius = {};
      if (parsed.radii.length === 1) {
        theme.extend.borderRadius.DEFAULT = parsed.radii[0];
      } else {
        theme.extend.borderRadius.sm = parsed.radii[0];
        theme.extend.borderRadius.DEFAULT = parsed.radii[Math.floor(parsed.radii.length / 2)];
        theme.extend.borderRadius.lg = parsed.radii[parsed.radii.length - 1];
      }
    }

    // Box shadows
    if (parsed.shadows.length > 0) {
      theme.extend.boxShadow = {};
      parsed.shadows.forEach((s, i) => {
        theme.extend.boxShadow[i === 0 ? 'card' : `card-${i + 1}`] = s;
      });
    }

    // Transitions
    if (parsed.transitions.durations.length > 0) {
      theme.extend.transitionDuration = {
        DEFAULT: parsed.transitions.durations[0],
      };
    }

    // Clean empty extend sub-objects
    for (const key of Object.keys(theme.extend)) {
      if (typeof theme.extend[key] === 'object' && Object.keys(theme.extend[key]).length === 0) {
        delete theme.extend[key];
      }
    }

    // Serialize
    const configStr = formatConfig(parsed.title, theme);

    return {
      content: [{ type: 'text', text: configStr }],
    };
  } catch (err) {
    if (err instanceof StyleNotFoundError) {
      return {
        isError: true,
        content: [{ type: 'text', text: err.message }],
      };
    }
    throw err;
  }
}

function formatConfig(title, theme) {
  const lines = [
    `// tailwind.config.ts â€” ${title} theme`,
    '// Generated by designbrief MCP server',
    '',
    'import type { Config } from "tailwindcss";',
    '',
    'const config: Partial<Config> = {',
    '  theme: ' + indent(serialize(theme), 2).trimStart() + ',',
    '};',
    '',
    'export default config;',
  ];
  return lines.join('\n');
}

function serialize(obj, depth = 0) {
  if (typeof obj === 'string') return JSON.stringify(obj);
  if (Array.isArray(obj)) {
    const items = obj.map(v => serialize(v, depth + 1));
    return '[' + items.join(', ') + ']';
  }
  if (typeof obj === 'object' && obj !== null) {
    const entries = Object.entries(obj);
    if (entries.length === 0) return '{}';
    const pad = '  '.repeat(depth + 1);
    const closePad = '  '.repeat(depth);
    const lines = entries.map(([k, v]) => {
      const key = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(k) ? k : JSON.stringify(k);
      return `${pad}${key}: ${serialize(v, depth + 1)},`;
    });
    return '{\n' + lines.join('\n') + '\n' + closePad + '}';
  }
  return String(obj);
}

function indent(str, spaces) {
  const pad = '  '.repeat(spaces);
  return str.split('\n').map((line, i) => i === 0 ? line : pad + line).join('\n');
}
